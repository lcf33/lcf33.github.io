<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lcf33&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lcf33.github.io/"/>
  <updated>2020-06-05T09:03:22.048Z</updated>
  <id>https://lcf33.github.io/</id>
  
  <author>
    <name>lcf33</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>盲打数字键</title>
    <link href="https://lcf33.github.io/2020/04/22/%E7%9B%B2%E6%89%93%E6%95%B0%E5%AD%97%E9%94%AE/"/>
    <id>https://lcf33.github.io/2020/04/22/%E7%9B%B2%E6%89%93%E6%95%B0%E5%AD%97%E9%94%AE/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.048Z</updated>
    
    <content type="html"><![CDATA[<p>最近刻意练习了下键盘数字键的盲打，感觉输入更加顺畅了。下面总结下练习过程和一点练习技巧。</p><a id="more"></a><h2 id="为什么要练习数字键盲打？"><a href="#为什么要练习数字键盲打？" class="headerlink" title="为什么要练习数字键盲打？"></a>为什么要练习数字键盲打？</h2><p>本人经常使用键盘，所以一直在注意提高输入效率的提升。之前已经累计完成了字母区盲打、常用标点盲打、双拼输入法、方向键映射。但是本人发现数字输入也不少，盲打5、6、9、0时总是出错。</p><p>发现欠缺就要练习提高。</p><h2 id="盲打分析"><a href="#盲打分析" class="headerlink" title="盲打分析"></a>盲打分析</h2><p>先简单说下数字小键盘盲打。如果使用标准键盘，而且一次性输入比较多的数字，可以将右手移到数字小键盘区输入。</p><p>数字小键盘区盲打比较好练，记住三点：</p><ul><li>记住3X3的数字分布</li><li>初始单指放在基准键5上，单次击键后就归位</li><li>输入时眼睛注意屏幕</li></ul><p>熟悉后还可以增加指头，本人感觉单指就够用了。</p><p>数字小键盘毕竟还要右手移到比较大的距离。如果文字数字混输就不合适使用数字小键盘。我着重练习的就是字母区上面的一行数字键盲打。</p><p>根据指法和我个人习惯，1、2、3分别由左手小指、无名指、中指击打，5、6由左食指击打，8、9、0分别由右手中指、无名指、小指击打，6、7又右食指击打。这行数字键击打需要手指移动比较大的距离，所以一开始练习击打不准很正常。</p><p>练习了几天，效果不是很好，总结下：5、6、9、0四个键容易击不准，1、2、3、8、9、0六个键有时击错或用错手指。然后我就这两方面进行专项练习。击键不准，主要是手指对键位空间不熟悉。除了枯燥无聊的大量练习，我参照基准键的思想总结出一个练习小技巧：</p><ul><li>多练1234 7890八个键的指法，关键在于手指向左上移动，练多了就熟悉适当的移动距离</li><li>以4、7分别为5、6的基准键，当熟悉上一步指法后就不难击打5、6</li></ul><p>简单讲就是让手指先熟悉统一的移动方向和距离，然后以4、7为基准键让食指熟悉另一个移动的方向和距离。有了这个技巧，还是需要多练习。本质上还是让手指形成记忆。</p><p>至于个别键容易击错或用错手指，在练习12347890八个键指法的过程就解决了。出现这种问题，本质是手指不适应新的键位击打。多练。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刻意练习了下键盘数字键的盲打，感觉输入更加顺畅了。下面总结下练习过程和一点练习技巧。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="awsome" scheme="https://lcf33.github.io/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>技能树</title>
    <link href="https://lcf33.github.io/2019/12/09/%E6%8A%80%E8%83%BD%E6%A0%91/"/>
    <id>https://lcf33.github.io/2019/12/09/%E6%8A%80%E8%83%BD%E6%A0%91/</id>
    <published>2019-12-08T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.047Z</updated>
    
    <content type="html"><![CDATA[<p>学习学习再学习</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/lcf33/picture_lcf/master/%E6%8A%80%E8%83%BD%E6%A0%91.jpg" alt="技能树202005"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习学习再学习&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="xmind" scheme="https://lcf33.github.io/tags/xmind/"/>
    
  </entry>
  
  <entry>
    <title>纠正跑姿</title>
    <link href="https://lcf33.github.io/2018/08/13/%E7%BA%A0%E6%AD%A3%E8%B7%91%E5%A7%BF/"/>
    <id>https://lcf33.github.io/2018/08/13/%E7%BA%A0%E6%AD%A3%E8%B7%91%E5%A7%BF/</id>
    <published>2018-08-12T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.048Z</updated>
    
    <content type="html"><![CDATA[<p>跑步有两个月了。最近有意了解跑步相关的信息，从图书馆借了两本书。看了《画说跑步那些事》，觉得自己要调整的地方挺多的，比如跑姿、呼吸、跑后拉伸、力量和韧性训练。其中最急需学习的就是跑姿了。</p><a id="more"></a><p>我按照书中介绍的“姿势跑步法”纠正。这种方法核心是支撑脚、身体重心和头所成直线与地面垂直，并且支撑腿弯曲、前脚掌先着地。过去我后脚跟先着地，步幅偏大，而且感觉前进腿有点往前趟的动作（这个不太清楚，之前都没怎么注意，而且没有自己录像看）。看了“姿势跑步法”，我很同意作者的观点，并且手打了一份方法要领，但是做起来有点困难。</p><p>困难的地方主要在于习惯。今天跑步我刻意使用“姿势跑步法”，开始总觉得怪怪的，支撑腿落地时有点砸地的感觉。而且跑步时感觉前进腿抬得有些低，这种跑姿因该类似原地踏步。这两个情况可能需要用录下我的跑步视频来反查改进。还有一个问题就是跑一段时间姿势有点变形，这个多注意纠正保持，跑量多了因该能解决。</p><p>此外，《画说跑步那些事》里面介绍“姿势跑步法”可能有简化。改天找来源头《跑步，该怎么跑》看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跑步有两个月了。最近有意了解跑步相关的信息，从图书馆借了两本书。看了《画说跑步那些事》，觉得自己要调整的地方挺多的，比如跑姿、呼吸、跑后拉伸、力量和韧性训练。其中最急需学习的就是跑姿了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="awsome" scheme="https://lcf33.github.io/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>晨间日记随想</title>
    <link href="https://lcf33.github.io/2018/08/12/%E6%99%A8%E9%97%B4%E6%97%A5%E8%AE%B0%E9%9A%8F%E6%83%B3/"/>
    <id>https://lcf33.github.io/2018/08/12/%E6%99%A8%E9%97%B4%E6%97%A5%E8%AE%B0%E9%9A%8F%E6%83%B3/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.047Z</updated>
    
    <content type="html"><![CDATA[<p>写日记好处很多，但是从小达到有多人坚持写了？整理自己的一天或者一段时间，尤其是持续整理，没多少人不烦。因为要动脑。</p><a id="more"></a><p>其次是人有惰性。传统写日记可能出现“今日无事”情况，第二天也可能出现同种情况，然后就中断了记日记。</p><p>今年6月开始跑步，就随手建了一个文本记录每天跑步情况。实践久了即使休息不跑我也要打开写一句“今日休息没跑步”。后来我增加了记录吃晚饭情况，随后又增加了每天平板支撑数据。今天看了《晨间日记》，忽然明白：普通的日记太过随意，关注所有等于没有关注。要是提前设定好每日关注点或者阶段任务，就容易持续记录了。</p><p>曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？” 先贤很早就讲具体的方法，但是我只关注了“三省吾身”，没有深入思考古人的方法论。只需简单迁移，吾日三省吾身：跑步了没？晚餐吃多没？平板支撑达标没？哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写日记好处很多，但是从小达到有多人坚持写了？整理自己的一天或者一段时间，尤其是持续整理，没多少人不烦。因为要动脑。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="awsome" scheme="https://lcf33.github.io/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>为什么beancount没用起来</title>
    <link href="https://lcf33.github.io/2018/06/10/%E4%B8%BA%E4%BB%80%E4%B9%88beancount%E6%B2%A1%E7%94%A8%E8%B5%B7%E6%9D%A5/"/>
    <id>https://lcf33.github.io/2018/06/10/%E4%B8%BA%E4%BB%80%E4%B9%88beancount%E6%B2%A1%E7%94%A8%E8%B5%B7%E6%9D%A5/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.045Z</updated>
    
    <content type="html"><![CDATA[<p>想更换beancount为新记账工具是5月15日。到现在三周多过去，beancount文档没有开始，之前随手记app记账也断了。</p><a id="more"></a><p>当时想更换记账工具，出发点有：</p><ul><li>了解过些会计知识，甚至2016年时打算考会计证书，对复式记账有兴趣</li><li>复式记账更有利把握现金流，随手记等app对一些情景不好处理</li><li>手机app记账虽然比本子方便、不宜忘记，但有时还是会漏记</li><li>现在很少用到现金，刷卡刷微信刷支付宝都可以电子回溯，甚至导出csv文件。即现在很少用现金的人可以每隔段时间整理下自己的账务。</li></ul><p>beancount可以导入csv文档，又采用复式记账。所以我想转用beancount，于是开始阅读beancount的文档。其实在它之前，我还用过几天gnucash。当时不熟悉操作界面，又没想到自动导入——感觉纯手动输入工作量好大。那时无意间看到网上一篇beancount的教程，立刻放弃gnucash。beancount比gnucash优势有两个：纯文本记账，没有gnucash操作复杂；gnucash bug多。</p><p>我开始觉得beancount简单，但有两个地方卡住了。一开始是英文文档。网上beancount的中文参考特别少，差不多能找到的就是两篇教程。这教程只包含了复式记账的基本概念和beancount常用的功能。于是只能看英文文档。beancount的作者是个勤奋的家伙，一个软件写了很多篇文档，每个文档侧重不同，最重要的是它们都很长。我耐着性子，一遍查词典一遍看，越看越觉得罗里吧嗦，火大。</p><p>另一个是导入器的使用。囫囵地看了几篇文档，用了我好几天，已经处于崩溃的边缘。这时读到导入器使用，文档差不多读了一半就见作者要使用者自己编写python3的导入配置文件。看到这我直接疯了。中间尝试给一个写过中文教程的大神发邮件请教，人家也很快回复了。但是我还是不会写、不会用，又不好意思再发邮件问，就想着自己再琢磨琢磨。</p><p>差不多这个时候半个月过去了。公司忙就放下了“琢磨”——一放就放到了10天。从一开决定用beancount，我就停到了随手记app，所以造成了现在的样子。。。</p><p>英文阅读能力差可以耐心看并积极学英语，python3的配置文件不会编写可以先找一篇别人的文件分析、学习python3，公司事情忙可以合理协调、分配时间。但是反思自己最近的状态，三方面做的都不好。可能是三方面相互掺杂，弄得我心烦——还是内心不够强大。内心强大的人不怕困难，分解难题，分配各项工作。这方面要加强可以训练。</p><p>鉴于我对复式记账还是不熟悉，暂时转用gnucash。说“转用”不够准确，应该是学习使用。暂时定为半年到一年吧，等到熟练各项会计准则、gnucash和积累一定个人复式记账技巧，再开启beancount数豆之旅。对这段时间财务学习任务，我大概想到的有：1、以初级会计考试为蓝本学习会计知识，2、阅读gnucash帮助文档，用gnucash记个人账，熟悉后可以尝试公司记账，3、积累、打磨个人记账中五大会计要素中科目分类，4、定期总结会计学习，文字输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想更换beancount为新记账工具是5月15日。到现在三周多过去，beancount文档没有开始，之前随手记app记账也断了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="awsome" scheme="https://lcf33.github.io/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>记账：支出收入分类</title>
    <link href="https://lcf33.github.io/2018/05/19/%E8%AE%B0%E8%B4%A6%EF%BC%9A%E6%94%AF%E5%87%BA%E6%94%B6%E5%85%A5%E5%88%86%E7%B1%BB/"/>
    <id>https://lcf33.github.io/2018/05/19/%E8%AE%B0%E8%B4%A6%EF%BC%9A%E6%94%AF%E5%87%BA%E6%94%B6%E5%85%A5%E5%88%86%E7%B1%BB/</id>
    <published>2018-05-18T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.049Z</updated>
    
    <content type="html"><![CDATA[<p>记账可能首先面对就是支出项、收入项、账户的建立。这篇提供一个框架，每个人的生活环境不一样，在这基础上修改相对简单些。</p><a id="more"></a><h2 id="支出分类"><a href="#支出分类" class="headerlink" title="支出分类"></a>支出分类</h2><ul><li>食品酒水：早午晚餐、食材、水果、零食、烟酒茶饮</li><li>衣服饰品：衣服、鞋帽包包、化妆饰品</li><li>行车交通：公共交通、打车出租、私家车费用（加油、维修保养、汽车保险、高速路费、违章罚款、停车费）</li><li>居家物业：日常用品、房租、水电煤气、物业管理、维修保养</li><li>交流通讯：座机费、手机费、上网费、邮寄费</li><li>休闲娱乐：运动健身、聚会、休闲玩乐、旅游度假、音乐电影、宠物宝贝</li><li>学习进修：书报杂志、培训进修、数码设备</li><li>人情往来：送礼请客、孝敬家长、还人钱物、慈善捐助、红白喜事</li><li>医疗美容：药品费、保健费、美容费、治疗费、理发</li><li>金融保险：银行手续、投资亏损、按揭还款、消费税收、利息支出、赔偿罚款、保险</li><li>其他杂项：其他支出、意外丢失、烂账损失</li></ul><h2 id="收入分类"><a href="#收入分类" class="headerlink" title="收入分类"></a>收入分类</h2><ul><li>职业收入：工资收入、奖金收入、利息收入、加班收入、投资收入、兼职收入</li><li>其他收入：经营所得、中奖收入、意外来钱、礼金收入、家长赠送</li></ul><h2 id="账户分类"><a href="#账户分类" class="headerlink" title="账户分类"></a>账户分类</h2><p>这个比较灵活，但是尽量与真实账户一致，比如设置借记卡、信用卡、支付宝微信、饭卡、会员储值卡等。这样设置的好处是条理清晰，账不容易乱。</p><ul><li>现金账户：钱包</li><li>金融账户：各行借记卡（平安、浦发、招商、华夏、工商、浙商）其他行还款时可能需要，要是不用本行借记卡还款则暂时不需要Open</li><li>虚拟账户：支付宝、微信、京东金融、51人品</li><li>信用卡账户：花呗、白条、各行信用卡</li><li>投资账户：华泰证券</li></ul><p>ps，以上是按随手记app设计。随手记为了方便使用，app分为账户、流水、借贷、证券几块，一般常用前两者。流水账流水很好记，时间、项目、金额三要素即可，关键在于账户设置。账户是否层次清晰、全面适用决定了记账体验和后期统计。所以花点时间琢磨优化账户设置是很有必要的。会计五要素有：资产、所有者权益、负债、收入、支出。普通记账不涉及所有者权益，资产和负债构成了上面对账户分类。其实账户设置不难，遵照实际情况，有什么就设置什么。收入和支出尽可能做到细致、清晰、易查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记账可能首先面对就是支出项、收入项、账户的建立。这篇提供一个框架，每个人的生活环境不一样，在这基础上修改相对简单些。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="awsome" scheme="https://lcf33.github.io/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>T004netstat、ss</title>
    <link href="https://lcf33.github.io/2017/11/23/T004netstat%E3%80%81ss/"/>
    <id>https://lcf33.github.io/2017/11/23/T004netstat%E3%80%81ss/</id>
    <published>2017-11-22T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.042Z</updated>
    
    <content type="html"><![CDATA[<p>netstat<br>ss</p><a id="more"></a><h2 id="netstat简介"><a href="#netstat简介" class="headerlink" title="netstat简介"></a>netstat简介</h2><p>netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括  tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。如果你想确认系统上的 Web  服务有没有起来，你可以查看80端口有没有打开。以上功能使 netstat  成为网管和系统管理员的必备利器。 </p><p><strong>列出所有连接</strong> <code>netstat -a</code></p><p><strong>只列出TCP协议的连接</strong> <code>netstat -at</code> 。类似的，如果列出所有udp协议连接使用 -u ，如果列出所有unix套接字使用 -x。</p><p><strong>禁用反向解析域名</strong> <code>netstat -ant</code> 如果要查看ip和port，使用 -n 。</p><p><strong>只列出监听中的连接</strong> <code>netstat -tnl</code>  任何网络服务的后台进程都会打开一个端口，用于监听接入的请求。 -l 列出LISTEN状态的端口。查看所有监听端口，去掉 -t，不用使用 -a（会列出所有连接），查看udp端口使用-u。</p><p><strong>获取PID、UID</strong> <code>netstat -nltp</code> 查看监听端口的服务进程，使用 -p 。要看用户，使用 -e。注意，-n和-e一起出现，user会转换为UID。</p><p><strong>打印统计数据</strong> <code>netstat -s</code> 统计数据包括某个协议的收发包数量。</p><p><strong>显示内核路由信息</strong> <code>netstat -rn</code> 使用 -n禁止域名解析。</p><p><strong>打印网络接口</strong> <code>netstat -i</code> 显示网络接口（网卡）信息，再加-e显示格式更友好。</p><p><strong>持续输出</strong> <code>netstat -tc</code> 该命令持续输出tcp协议信息。</p><p><strong>显示多播组信息</strong> <code>netstat -g</code> 输出IPv4和IPv6的多播组信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;netstat&lt;br&gt;ss&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>T003echo</title>
    <link href="https://lcf33.github.io/2017/11/21/T003echo/"/>
    <id>https://lcf33.github.io/2017/11/21/T003echo/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.041Z</updated>
    
    <content type="html"><![CDATA[<p>cheat sheet about echo</p><a id="more"></a><h2 id="echo常用参数"><a href="#echo常用参数" class="headerlink" title="echo常用参数"></a>echo常用参数</h2><p>echo 命令的基本用法，很简单，就是 echo 命令后面跟上要输出的文本。</p><p>echo -n 表示不换行输出 。例如在ncat（nmap 子工具）6.4版本中没有 -z 参数（不发送字节），这时可以用echo和管道来实现。<code>echo -n &quot;&quot; | nc -v ip port</code> 。</p><p><img src="https://raw.githubusercontent.com/lcf33/picture_lcf/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200319091819.png" alt="-n区别"></p><p>echo -e 表示支持转义。常见的转义字符有：</p><ul><li>\b 转义相当于按退格键（backspace），但前提是“\b”后面存在字符，具体效果参考下方示例。</li><li>\c 不换行输出，在“\c”后面不存在字符的情况下，作用相当于echo -n，具体效果参考下方示例。</li><li>\n 换行，效果看示例。</li><li>\f 换行，但是换行后的新行的开头位置连接着上一行的行尾，具体效果查看示例。</li><li>\v 与\f 相同；</li><li>\t 转以后表示插入tab，即制表符，已经在上面举过例子；</li><li>\r 光标移至行首，但不换行，相当于使用“\r”以后的字符覆盖“\r”之前同等长度的字符，只看这段文字描述的话可能不容易理解，具体效果查看示例。</li><li>两个\表示插入“\”本身；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cheat sheet about echo&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>T002NTP服务</title>
    <link href="https://lcf33.github.io/2017/11/19/T002NTP%E6%9C%8D%E5%8A%A1/"/>
    <id>https://lcf33.github.io/2017/11/19/T002NTP%E6%9C%8D%E5%8A%A1/</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.040Z</updated>
    
    <content type="html"><![CDATA[<p>NTP服务<br>服务端、客户端实战</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>NTP （Network Time Protocol）意即网络时间协议。它是通过网络在计算机系统之间进行时钟同步的网络协议。换言之，它可以让那些通过 NTP 或者 Chrony 客户端连接到 NTP 服务器的系统保持时间上的一致（它能保持一个精确的时间）。</p><p>NTP 在公共互联网上通常能够保持时间延迟在几十毫秒以内的精度，并在理想条件下，它能在局域网下达到低于一毫秒的延迟精度。它使用用户数据报协议（UDP）在端口 123 上发送和接受时间戳。它是个 C/S 架构的应用程序。</p><p>为了使你组织中的所有服务器与基于时间的作业保持精确的时间同步。比如说，我们有两个服务器（服务器 1 和服务器 2）。服务器 1 通常在 10:55 完成离线作业，然后服务器 2 在 11:00 需要基于服务器 1 完成的作业报告去运行其他作业。如果两个服务器正在使用不同的时间（如果服务器 2 时间比服务器 1 提前，服务器 1 的时间就落后于服务器 2），然后我们就不能去执行这个作业。为了达到时间一致，我们应该安装 NTP。</p><p>假设有一下两台机子：</p><ul><li>NTP 服务器： 主机名：CentOS7.2daygeek.com，IP：192.168.1.8，OS：CentOS 7</li><li>NTP 客户端： 主机名：Ubuntu18.2daygeek.com，IP：192.168.1.5，OS：Ubuntu 18.04</li></ul><p>因为它是 C/S 架构，所以 NTP 服务器端和客户端的安装包没有什么不同。在发行版的官方仓库中都有 NTP 安装包，因此可以使用发行版的包管理器安装它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ntp</span><br><span class="line">sudo yum install ntp</span><br></pre></td></tr></table></figure><h2 id="NTP服务端"><a href="#NTP服务端" class="headerlink" title="NTP服务端"></a>NTP服务端</h2><p>安装 NTP 软件包后，请确保在服务器端的 /etc/ntp.conf 文件中取消以下配置的注释。默认情况下，NTP 服务器配置依赖于 X.distribution_name.pool.ntp.org。 如果有必要，可以使用默认配置，也可以访问<a href="https://www.ntppool.org/zone/@站点，根据你所在的位置（特定国家/地区）进行更改。" target="_blank" rel="noopener">https://www.ntppool.org/zone/@站点，根据你所在的位置（特定国家/地区）进行更改。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;ntp.conf</span><br><span class="line">restrict default kod nomodify notrap nopeer noquery</span><br><span class="line">restrict -6 default kod nomodify notrap nopeer noquery</span><br><span class="line">restrict 127.0.0.1</span><br><span class="line">restrict -6 ::1</span><br><span class="line">server 0.asia.pool.ntp.org</span><br><span class="line">server 1.asia.pool.ntp.org</span><br><span class="line">server 2.asia.pool.ntp.org</span><br><span class="line">server 3.asia.pool.ntp.org</span><br><span class="line">restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap #仅允许 192.168.1.0&#x2F;24 子网的客户端访问这个 NTP 服务器。</span><br><span class="line">driftfile &#x2F;var&#x2F;lib&#x2F;ntp&#x2F;drift</span><br><span class="line">keys &#x2F;etc&#x2F;ntp&#x2F;keys</span><br></pre></td></tr></table></figure><p>由于默认情况下基于 RHEL7 的发行版的防火墙是打开的，因此要允许 ntp 服务通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --add-service&#x3D;ntp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>更新配置后要重启服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于 sysvinit 系统:</span><br><span class="line"># service ntpd restart</span><br><span class="line"># chkconfig ntpd on</span><br><span class="line"></span><br><span class="line">对于 systemctl 系统</span><br><span class="line"># systemctl restart ntpd</span><br><span class="line"># systemctl enable ntpd</span><br></pre></td></tr></table></figure><h2 id="NTP-客户端"><a href="#NTP-客户端" class="headerlink" title="NTP 客户端"></a>NTP 客户端</h2><p>NTP 服务器端和客户端的安装包没有什么不同。因此在客户端上也安装同样的软件包。参考上面命令。</p><p>我已经在 CentOS7.2daygeek.com 这台主机上安装和配置了 NTP 服务器，因此将其附加到所有的客户端机器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;ntp.conf</span><br><span class="line">restrict default kod nomodify notrap nopeer noquery</span><br><span class="line">restrict -6 default kod nomodify notrap nopeer noquery</span><br><span class="line">restrict 127.0.0.1</span><br><span class="line">restrict -6 ::1</span><br><span class="line">server CentOS7.2daygeek.com prefer iburst</span><br><span class="line">driftfile &#x2F;var&#x2F;lib&#x2F;ntp&#x2F;drift</span><br><span class="line">keys &#x2F;etc&#x2F;ntp&#x2F;keys</span><br></pre></td></tr></table></figure><p>更新完配置要重启服务。重新启动 NTP 服务后等待几分钟以便从 NTP 服务器获取同步的时间。</p><p>在 Linux 上运行下列命令去验证 NTP 服务的同步状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ntpq –p</span><br><span class="line">或</span><br><span class="line"># ntpq -pn</span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">*CentOS7.2daygee 133.243.238.163  2 u   14   64   37    0.686    0.151  16.432</span><br></pre></td></tr></table></figure><p>运行下列命令去得到 ntpd 的当前状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ntpstat</span><br><span class="line">synchronised to NTP server (192.168.1.8) at stratum 3</span><br><span class="line">   time correct to within 508 ms</span><br><span class="line">   polling server every 64 s</span><br></pre></td></tr></table></figure><p>如果你观察到 NTP 中输出的时间偏移很大。运行下列命令从 NTP 服务器手动同步时钟。当你执行下列命令的时候，确保你的 NTP 客户端应该为未活动状态。当时间偏差很大时，客户端的自动校正需要花费很长时间才能逐步追上，因此应该手动运行以更新。</p><p><a href="https://linux.cn/article-10951-1.html" target="_blank" rel="noopener">确认ntp状态</a></p><h2 id="Chrony"><a href="#Chrony" class="headerlink" title="Chrony"></a>Chrony</h2><p>Chrony 是 NTP 客户端的替代品。它能以更精确的时间更快的同步系统时钟，并且它对于那些不总是在线的系统很有用。<br><a href="https://linux.cn/article-10820-1.html" target="_blank" rel="noopener">chrony</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NTP服务&lt;br&gt;服务端、客户端实战&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>T001netcat</title>
    <link href="https://lcf33.github.io/2017/11/17/T001netcat/"/>
    <id>https://lcf33.github.io/2017/11/17/T001netcat/</id>
    <published>2017-11-16T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.039Z</updated>
    
    <content type="html"><![CDATA[<p>netcat简介<br>使用思路<br>实战：端口测试、信息传输、文件传输、网络吞吐测试、系统后门</p><a id="more"></a><h2 id="netcat简介"><a href="#netcat简介" class="headerlink" title="netcat简介"></a>netcat简介</h2><p>netcat具有“网络瑞士军刀“之称，支持从命令行跨网络读取和写入数据。</p><p>netcat 有 GNU 版本和 OpenBSD版本。两者都可以在 Linux下面安装，但是 Windows 下面只有 GNU 版本。 不管是 GNU 版本还是 OpenBSD 版本，都有新老的区别，主要是传送文件时 stdin 发生 EOF 了，老版本会自动断开，而新的 gnu/openbsd 还会一直连着 。</p><p>NcatNmap项目套件中有一个ncat程序。Ncat最初是用来支持Nmap而开发的，是对古老的Netcat重新实现的一个大大改进。它与netcat类似，使用TCP和UDP进行通信，可为其他应用程序和用户提供网络连接。</p><p>这三个版本功能类似，都简称nc。 <code>readlink -f $(which nc)</code> 查看nc版本。在使用时常用功能区别不大，如果遇到什么问题，查看系统自带手册（网上教程、博客可能不准）。</p><h2 id="软件使用思路"><a href="#软件使用思路" class="headerlink" title="软件使用思路"></a>软件使用思路</h2><p> netcat 可以操作 tcp/udp 进行原始的监听、连接、数据传输等工作。然后搭配管道，实现灵活多样的功能，或者进行各种网络测试。 下面是nc常用功能。</p><h2 id="端口测试"><a href="#端口测试" class="headerlink" title="端口测试"></a>端口测试</h2><p>测试端口第一个想到的是telnet，但是有一定局限性：telnet不一定安装，需要有额外主机测试。</p><p>使用nc可以在本机测试端口是否监听<code>nc -l -p port</code> 。如果报端口已占用，表示端口已经监听。</p><p>本机端口已监听，如果还以网络不通，可在第二台主机上执行<code>nc -vz ip port</code> 。v 表示verbose，显示多点信息。z 表示不发送数据。</p><p> nc 命令后面的 8080 可以写成一个范围进行扫描： <code>nc -v -v -w3 -z ip port1-port2</code> 。两次 v 会显示更详细的内容，w3是设置扫描超时时间为3秒。</p><h2 id="传输测试"><a href="#传输测试" class="headerlink" title="传输测试"></a>传输测试</h2><p>在A主机(192.168.1.2)上执行<code>nc -l -p 8080</code> ，开始监听本地8080端口。然后在B主机上连接A：<code>nc 192.168.1.2 8080</code> 。 两边就可以会话了，随便输入点什么按回车，另外一边应该会显示出来 。</p><p>openbsd 版本 netcat 用了 <code>-l</code> 以后可以省略 <code>-p</code> 参数，写做：<code>nc -l 8080</code> ，但在 GNU netcat 下面无法运行，所以推荐写法是加上 <code>-p</code> 参数，两个版本都通用。 老版本的 nc 只要 CTRL+D 发送 EOF 就会断开，新版本一律要 CTRL+C 结束，不管是服务端还是客户端只要任意一边断开了，另一端也就结束了，但是 openbsd 版本的 nc 可以加一个 -k 参数让服务端持续工作。  </p><h2 id="测试UDP"><a href="#测试UDP" class="headerlink" title="测试UDP"></a>测试UDP</h2><p>排查两台主机 UDP 数据发送不通问题。在A主机(192.168.1.2)上执行<code>nc -u -l -p 8080</code> ，监听udp的8080端口。然后B主机测试连接<code>nc -u 192.168.1.2 8080</code> 。</p><p>类似上面测试，看看一边输入消息另外一边能否收到，收得到的话可能是你自己的服务原因，收不到的话，检查网关、防火墙等配置。</p><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><p>两台服务器传输文件，可以用scp、szrz，也可以安装FTP服务，甚至可以动手用Python实现http上传。用nc也可以轻松实现。</p><p>在A主机（192.168.1.2）上监听端口<code>nc -l -p 8080 &gt; image.jpg</code> 。然后在B主机上发送文件 <code>nc 192.168.1.2 8080 &lt; image.jpg</code> 。</p><p>注意，老版本 GNU / OpenBSD 的 netcat 再文件结束（标准输入碰到 EOF），发送文件一端就会关闭连接，而新版本不会，需要验证传输文件和源文件是否大小一致。openbsd版可以使用<code>-N</code> 参数，指明stdin遇到EOF就关闭连接（完成传输），GNU版本可以用<code>-q0</code> 参数。</p><p>nc进行文件传输，在极端环境下很有用。</p><h2 id="网速吞吐量测试"><a href="#网速吞吐量测试" class="headerlink" title="网速吞吐量测试"></a>网速吞吐量测试</h2><p>GNU版本使用<code>-v -v</code> 参数，在结束时会统计接受和发送的字节。</p><p>在A主机（192.168.1.2）上监听8080 <code>nc -v -v -n -l -p 8080 &gt; /dev/null</code> 。-n是不要解析域名，避免解析域名造成时间误差。然后在B主机上执行 <code>time nc -n 192.168.1.2 8080 &lt; /dev/zero</code> 。执行一段时间后 CTRL+C 结束，就可以在A主机上查看字节数，在根据B主机的时长就可以计算。</p><p>对于 OpenBSD 版本的 nc 我们可以用管道搭配 dd 命令进行统计，服务端运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 8080 &gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>客户端运行 dd 搭配 nc，结束以后会有结果出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero bs&#x3D;1MB count&#x3D;100 | &#x2F;bin&#x2F;nc.openbsd -n -N 192.168.1.2 8080</span><br></pre></td></tr></table></figure><p>其实上面两种方法都把建立连接的握手时间以及 TCP 窗口慢启动的时间给计算进去了，不是特别精确，最精确的方式是搭配 pv 命令（监控统计管道数据的速度），在 A 主机运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 8080 | pv</span><br></pre></td></tr></table></figure><p>然后再 B 主机运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.1.2 8080 &lt; &#x2F;dev&#x2F;zero</span><br></pre></td></tr></table></figure><p>此时 A 主机那端持续收到 B 主机发送过来的数据并通过管道投递给 pv 命令后，你就能看到实时的带宽统计了，pv 会输出一个实时状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">353MiB 0:00:15 [22.4MiB&#x2F;s] [          &lt;&#x3D;&gt;  ]</span><br></pre></td></tr></table></figure><p>让你看到最新的带宽吞吐量，这是最准确的吞吐量测试方法，在不需要 iperf 的情况下，直接使用 nc 就能得到一个准确的数据。</p><h2 id="系统后门"><a href="#系统后门" class="headerlink" title="系统后门"></a>系统后门</h2><p>假设A 主机十分原始，包管理系统都没有，sshd/telnetd 都跑不起来，这时候可以用nc 来实现B 主机通过网络登录 A 主机。</p><p>GNU 版本的 netcat 有一个 -e 参数，可以在连接建立的时候执行一个程序，并把它的标准输入输出重定向到网络连接上来，于是我们可以在 A 主机上 -e 一下 bash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;nc.traditional -l -p 8080 -e &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>按回车打开系统后门，然后再 B 主机那里照常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.1.2 8080</span><br></pre></td></tr></table></figure><p>你就可以在 B 主机上登录 A 主机的 shell 了，操作完成 CTRL+C 结束。</p><p>对于 openbsd 版本的 netcat，-e 命令被删除了，没关系，我们可以用管道来完成，和刚才一样，在 A 主机上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo &#x2F;tmp&#x2F;fcat &#x2F;tmp&#x2F;f | &#x2F;bin&#x2F;bash 2&gt;&amp;1 | &#x2F;bin&#x2F;nc.openbsd -l -p 8080 &gt; &#x2F;tmp&#x2F;f</span><br></pre></td></tr></table></figure><p>然后 B 主机和刚才一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.1.2 8080</span><br></pre></td></tr></table></figure><p>即可访问，用完注意将 <code>/tmp/f</code> 这个 fifo 文件删除。</p><h2 id="还有很多用途"><a href="#还有很多用途" class="headerlink" title="还有很多用途"></a>还有很多用途</h2><p>还有很多其他用法，比如可以用 netcat + shell script 写一个 http 服务器，使用 fifo 搭配两层 nc 可以实现 tcp 端口转发，搭配 openssl 命令行工具和 nc 加管道可以把 ssl 的套接字解码并映射成裸的 socket 端口供没有 ssl 功能的工具访问。 这些功能比较考验基本能力，可能有些复杂，可以在极端恶劣环境下使用，平时用专用软件很容易实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;netcat简介&lt;br&gt;使用思路&lt;br&gt;实战：端口测试、信息传输、文件传输、网络吞吐测试、系统后门&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>069shell脚本05告警系统</title>
    <link href="https://lcf33.github.io/2017/11/15/069shell%E8%84%9A%E6%9C%AC05%E5%91%8A%E8%AD%A6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lcf33.github.io/2017/11/15/069shell%E8%84%9A%E6%9C%AC05%E5%91%8A%E8%AD%A6%E7%B3%BB%E7%BB%9F/</id>
    <published>2017-11-14T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.036Z</updated>
    
    <content type="html"><![CDATA[<p>告警系统主脚本<br>告警系统配置文件<br>告警系统监控项目<br>告警系统邮件引擎<br>运行告警系统</p><a id="more"></a><h2 id="告警系统需求分析"><a href="#告警系统需求分析" class="headerlink" title="告警系统需求分析"></a>告警系统需求分析</h2><p>需求：使用shell定制各种个性化告警工具，但需要统一化管理、规范化管理。<br>思路：指定一个脚本包，包含主程序、子程序、配置文件、邮件引擎、输出日志等。<br>主程序：作为整个脚本的入口，是整个系统的命脉。<br>配置文件：是一个控制中心，用它来开关各个子程序，指定各个相关联的日志文件。<br>子程序：这个才是真正的监控脚本，用来监控各个指标。<br>邮件引擎：是由一个python程序来实现，它可以定义发邮件的服务器、发邮件人以及发件人密码<br>输出日志：整个监控系统要有日志输出。</p><p>要求：我们的机器角色多种多样，但是所有机器上都要部署同样的监控系统，也就说所有机器不管什么角色，整个程序框架都是一致的，不同的地方在于根据不同的角色，定制不同的配置文件。</p><p>程序架构：bin下是主程序，conf下是配置文件，shares下是各个监控脚本，mail下是邮件引擎，log下是日志。</p><h2 id="告警主程序main-sh"><a href="#告警主程序main-sh" class="headerlink" title="告警主程序main.sh"></a>告警主程序main.sh</h2><p>main.sh内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Written by aming.</span><br><span class="line"># 是否发送邮件的开关</span><br><span class="line">export send&#x3D;1</span><br><span class="line"># 过滤ip地址</span><br><span class="line">export addr&#x3D;&#96;&#x2F;sbin&#x2F;ifconfig |grep -A1 &quot;ens33: &quot;|awk &#39;&#x2F;inet&#x2F; &#123;print $2&#125;&#39;&#96;</span><br><span class="line">dir&#x3D;&#96;pwd&#96;</span><br><span class="line"># 只需要最后一级目录名</span><br><span class="line">last_dir&#x3D;&#96;echo $dir|awk -F&#39;&#x2F;&#39; &#39;&#123;print $NF&#125;&#39;&#96;</span><br><span class="line"># 下面的判断目的是，保证执行脚本的时候，我们在bin目录里，不然监控脚本、邮件和日志很有可能找不到</span><br><span class="line">if [ $last_dir &#x3D;&#x3D; &quot;bin&quot; ] || [ $last_dir &#x3D;&#x3D; &quot;bin&#x2F;&quot; ]; then</span><br><span class="line">   conf_file&#x3D;&quot;..&#x2F;conf&#x2F;mon.conf&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;you shoud cd bin dir&quot;</span><br><span class="line">   exit</span><br><span class="line">fi</span><br><span class="line">exec 1&gt;&gt;..&#x2F;log&#x2F;mon.log 2&gt;&gt;..&#x2F;log&#x2F;err.log</span><br><span class="line">echo &quot;&#96;date +&quot;%F %T&quot;&#96; load average&quot;</span><br><span class="line">&#x2F;bin&#x2F;bash ..&#x2F;shares&#x2F;load.sh</span><br><span class="line">#先检查配置文件中是否需要监控502</span><br><span class="line">if grep -q &#39;to_mon_502&#x3D;1&#39; $conf_file; then</span><br><span class="line">   export log&#x3D;&#96;grep &#39;logfile&#x3D;&#39; $conf_file |awk -F &#39;&#x3D;&#39; &#39;&#123;print $2&#125;&#39; |sed &#39;s&#x2F; &#x2F;&#x2F;g&#39;&#96;</span><br><span class="line">   &#x2F;bin&#x2F;bash  ..&#x2F;shares&#x2F;502.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="配置文件mon-conf"><a href="#配置文件mon-conf" class="headerlink" title="配置文件mon.conf"></a>配置文件mon.conf</h2><p>mon.conf内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">## to config the options if to monitor</span><br><span class="line">## 定义mysql的服务器地址、端口以及user、password</span><br><span class="line">to_mon_cdb&#x3D;0   ##0 or 1, default 0,0 not monitor, 1 monitor</span><br><span class="line">db_ip&#x3D;10.20.3.13</span><br><span class="line">db_port&#x3D;3315</span><br><span class="line">db_user&#x3D;username</span><br><span class="line">db_pass&#x3D;passwd</span><br><span class="line">## httpd   如果是1则监控，为0不监控</span><br><span class="line">to_mon_httpd&#x3D;0</span><br><span class="line">## php 如果是1则监控，为0不监控</span><br><span class="line">to_mon_php_socket&#x3D;0</span><br><span class="line">## http_code_502  需要定义访问日志的路径</span><br><span class="line">to_mon_502&#x3D;1</span><br><span class="line">logfile&#x3D;&#x2F;data&#x2F;log&#x2F;xxx.xxx.com&#x2F;access.log</span><br><span class="line">## request_count   定义日志路径以及域名</span><br><span class="line">to_mon_request_count&#x3D;0</span><br><span class="line">req_log&#x3D;&#x2F;data&#x2F;log&#x2F;www.discuz.net&#x2F;access.log</span><br><span class="line">domainname&#x3D;www.discuz.net</span><br></pre></td></tr></table></figure><h2 id="监控项目"><a href="#监控项目" class="headerlink" title="监控项目"></a>监控项目</h2><p>load.sh内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">##Writen by aming##</span><br><span class="line">load&#x3D;&#96;uptime |awk -F &#39;average:&#39; &#39;&#123;print $2&#125;&#39;|cut -d&#39;,&#39; -f1|sed &#39;s&#x2F; &#x2F;&#x2F;g&#39; |cut -d. -f1&#96;</span><br><span class="line">if [ $load -gt 10 ] &amp;&amp; [ $send -eq &quot;1&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$addr &#96;date +%T&#96; load is $load&quot; &gt;..&#x2F;log&#x2F;load.tmp</span><br><span class="line">   &#x2F;bin&#x2F;bash ..&#x2F;mail&#x2F;mail.sh aming_test@163.com &quot;$addr\_load:$load&quot; &#96;cat ..&#x2F;log&#x2F;load.tmp&#96;</span><br><span class="line">fi</span><br><span class="line">echo &quot;&#96;date +%T&#96; load is $load&quot;</span><br></pre></td></tr></table></figure><p>load.sh内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">##Writen by aming##</span><br><span class="line">load&#x3D;&#96;uptime |awk -F &#39;average:&#39; &#39;&#123;print $2&#125;&#39;|cut -d&#39;,&#39; -f1|sed &#39;s&#x2F; &#x2F;&#x2F;g&#39; |cut -d. -f1&#96;</span><br><span class="line">if [ $load -gt 10 ] &amp;&amp; [ $send -eq &quot;1&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$addr &#96;date +%T&#96; load is $load&quot; &gt;..&#x2F;log&#x2F;load.tmp</span><br><span class="line">   &#x2F;bin&#x2F;bash ..&#x2F;mail&#x2F;mail.sh aming_test@163.com &quot;$addr\_load:$load&quot; &#96;cat ..&#x2F;log&#x2F;load.tmp&#96;</span><br><span class="line">fi</span><br><span class="line">echo &quot;&#96;date +%T&#96; load is $load&quot;</span><br></pre></td></tr></table></figure><p>502.sh内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">d&#x3D;&#96;date -d &quot;-1 min&quot; +%H:%M&#96;</span><br><span class="line">c_502&#x3D;&#96;grep :$d:  $log  |grep &#39; 502 &#39;|wc -l&#96;</span><br><span class="line">if [ $c_502 -gt 10 ] &amp;&amp; [ $send &#x3D;&#x3D; 1 ]; then</span><br><span class="line">     echo &quot;$addr $d 502 count is $c_502&quot;&gt;..&#x2F;log&#x2F;502.tmp</span><br><span class="line">     &#x2F;bin&#x2F;bash ..&#x2F;mail&#x2F;mail.sh $addr\_502 $c_502  ..&#x2F;log&#x2F;502.tmp</span><br><span class="line">fi</span><br><span class="line">echo &quot;&#96;date +%T&#96; 502 $c_502&quot;</span><br></pre></td></tr></table></figure><p>disk.sh内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">##Writen by aming##</span><br><span class="line">rm -f ..&#x2F;log&#x2F;disk.tmp</span><br><span class="line">for r in &#96;df -h |awk -F &#39;[ %]+&#39; &#39;&#123;print $5&#125;&#39;|grep -v Use&#96;</span><br><span class="line">do</span><br><span class="line">    if [ $r -gt 90 ] &amp;&amp; [ $send -eq &quot;1&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;$addr &#96;date +%T&#96; disk useage is $r&quot; &gt;&gt;..&#x2F;log&#x2F;disk.tmp</span><br><span class="line">fi</span><br><span class="line">if [ -f ..&#x2F;log&#x2F;disk.tmp ]</span><br><span class="line">then</span><br><span class="line">    df -h &gt;&gt; ..&#x2F;log&#x2F;disk.tmp</span><br><span class="line">    &#x2F;bin&#x2F;bash ..&#x2F;mail&#x2F;mail.sh $addr\_disk $r ..&#x2F;log&#x2F;disk.tmp</span><br><span class="line">    echo &quot;&#96;date +%T&#96; disk useage is nook&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;&#96;date +%T&#96; disk useage is ok&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="邮件引擎"><a href="#邮件引擎" class="headerlink" title="邮件引擎"></a>邮件引擎</h2><p>mail.sh内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  log&#x3D;$1</span><br><span class="line">t_s&#x3D;&#96;date +%s&#96;</span><br><span class="line">t_s2&#x3D;&#96;date -d &quot;2 hours ago&quot; +%s&#96;</span><br><span class="line">if [ ! -f &#x2F;tmp&#x2F;$log ]</span><br><span class="line">then</span><br><span class="line">   echo $t_s2 &gt; &#x2F;tmp&#x2F;$log</span><br><span class="line">fi</span><br><span class="line">t_s2&#x3D;&#96;tail -1 &#x2F;tmp&#x2F;$log|awk &#39;&#123;print $1&#125;&#39;&#96;</span><br><span class="line">echo $t_s&gt;&gt;&#x2F;tmp&#x2F;$log</span><br><span class="line">v&#x3D;$[$t_s-$t_s2]</span><br><span class="line">echo $v</span><br><span class="line">if [ $v -gt 3600 ]</span><br><span class="line">then</span><br><span class="line">   .&#x2F;mail.py  $1  $2  $3</span><br><span class="line">   echo &quot;0&quot; &gt; &#x2F;tmp&#x2F;$log.txt</span><br><span class="line">else</span><br><span class="line">   if [ ! -f &#x2F;tmp&#x2F;$log.txt ]</span><br><span class="line">   then</span><br><span class="line">       echo &quot;0&quot; &gt; &#x2F;tmp&#x2F;$log.txt</span><br><span class="line">   fi</span><br><span class="line">   nu&#x3D;&#96;cat &#x2F;tmp&#x2F;$log.txt&#96;</span><br><span class="line">   nu2&#x3D;$[$nu+1]</span><br><span class="line">   echo $nu2&gt;&#x2F;tmp&#x2F;$log.txt</span><br><span class="line">   if [ $nu2 -gt 10 ]</span><br><span class="line">   then</span><br><span class="line">        .&#x2F;mail.py  $1 &quot;trouble continue 10 min $2&quot; &quot;$3&quot;</span><br><span class="line">        echo &quot;0&quot; &gt; &#x2F;tmp&#x2F;$log.txt</span><br><span class="line">   fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;告警系统主脚本&lt;br&gt;告警系统配置文件&lt;br&gt;告警系统监控项目&lt;br&gt;告警系统邮件引擎&lt;br&gt;运行告警系统&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>068shell脚本04</title>
    <link href="https://lcf33.github.io/2017/11/13/068shell%E8%84%9A%E6%9C%AC04/"/>
    <id>https://lcf33.github.io/2017/11/13/068shell%E8%84%9A%E6%9C%AC04/</id>
    <published>2017-11-12T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.035Z</updated>
    
    <content type="html"><![CDATA[<p>shell中的函数<br>shell中的数组<br>告警系统需求分析</p><a id="more"></a><h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>函数就是把一段代码整理到了一个小单元中，并给这个小单元起一个名字，当用到这段代码时直接调用这个小单元的名字即可。<br>格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f_name() &amp;#123</span><br><span class="line">command</span><br><span class="line">&amp;#125</span><br></pre></td></tr></table></figure><p>函数必须要放在最前面，function可以省略。</p><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">input() &amp;#123</span><br><span class="line">echo $1 $2 $# $0</span><br><span class="line">&amp;#125</span><br><span class="line"></span><br><span class="line">input 1 a b</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sum() &amp;#123</span><br><span class="line">s&#x3D;$[$1+$2]</span><br><span class="line">echo $s</span><br><span class="line">&amp;#125</span><br><span class="line">sum 1 2</span><br></pre></td></tr></table></figure><p>示例3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">ip() &amp;#123</span><br><span class="line">ifconfig |grep -A1 &quot;$1&quot;|tail -1 |awk &#39;&amp;#123print $2&amp;#125&#39;|awk -F&#39;:&#39; &#39;&amp;#123print $2&amp;#125&#39;</span><br><span class="line">&amp;#125</span><br><span class="line">read -p &quot;Please input the eth name: &quot; e</span><br><span class="line">myip&#x3D;&#96;ip $e&#96;</span><br><span class="line">echo &quot;$e address is $myip&quot;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>定义数组 <code>a=(1 2 3 4 5);echo $&amp;#123a[@]&amp;#125</code><br><code>echo $&amp;#123#a[@]&amp;#125</code> 获取数组的元数个数<br><code>echo $&amp;#123a[2]&amp;#125</code> 读取第三个元素，数组从0开始<br><code>echo $&amp;#123a[*]&amp;#125</code> 等同于<code>$&amp;#123a[@]&amp;#125</code> 显示整个数组<br>数组赋值<br><code>a[1]=100;echo $&amp;#123a[@]&amp;#125</code><br><code>a[5]=2;echo $&amp;#123a[@]&amp;#125</code> 如果下标不存在则会自动添加一个元素<br>数组删除<br><code>unset a;unset a[1]</code></p><p>数组分片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;(&#96;seq 1 5&#96;)</span><br><span class="line">echo $&amp;#123a[@]:0:3&amp;#125 从第一个元素开始，截取3个</span><br><span class="line">echo $&amp;#123a[@]:1:4&amp;#125 从第二个元素开始，截取4个</span><br><span class="line">echo $&amp;#123a[@]:0-3:2&amp;#125 从倒数第三个元素开始，截取2个</span><br></pre></td></tr></table></figure><p>数组替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&amp;#123a[@]&#x2F;3&#x2F;100&amp;#125</span><br><span class="line">a&#x3D;($&amp;#123a[@]&#x2F;3&#x2F;100&amp;#125)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shell中的函数&lt;br&gt;shell中的数组&lt;br&gt;告警系统需求分析&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>067shell脚本03</title>
    <link href="https://lcf33.github.io/2017/11/11/067shell%E8%84%9A%E6%9C%AC03/"/>
    <id>https://lcf33.github.io/2017/11/11/067shell%E8%84%9A%E6%9C%AC03/</id>
    <published>2017-11-10T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.034Z</updated>
    
    <content type="html"><![CDATA[<p>while循环<br>break跳出循环<br>continue结束本次循环<br>exit退出整个脚本</p><a id="more"></a><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>语法 while 条件; do … ; done<br>案例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    load&#x3D;&#96;w|head -1|awk -F &#39;load average: &#39; &#39;&#123;print $2&#125;&#39;|cut -d. -f1&#96;</span><br><span class="line">    if [ $load -gt 10 ]</span><br><span class="line">    then</span><br><span class="line">        top|mail -s &quot;load is high: $load&quot; asldkfls@11.com</span><br><span class="line">    fi</span><br><span class="line">    sleep 30</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>案例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">while : #死循环</span><br><span class="line">do</span><br><span class="line">    read -p &quot;Please input a number: &quot; n</span><br><span class="line">    if [ -z &quot;$n&quot; ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;you need input sth.&quot;</span><br><span class="line">        continue #继续循环</span><br><span class="line">    fi</span><br><span class="line">    n1&#x3D;&#96;echo $n|sed &#39;s&#x2F;[0-9]&#x2F;&#x2F;g&#39;&#96; #判断是不是数字</span><br><span class="line">    if [ -n &quot;$n1&quot; ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;you just only input numbers.&quot;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line">    break #跳出while</span><br><span class="line">done</span><br><span class="line">echo $n</span><br></pre></td></tr></table></figure><h2 id="break跳出循环"><a href="#break跳出循环" class="headerlink" title="break跳出循环"></a>break跳出循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 5&#96;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">    if [ $i &#x3D;&#x3D; 3 ]</span><br><span class="line">    then</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line">echo aaaaaaa</span><br></pre></td></tr></table></figure><h2 id="continue结束本次循环"><a href="#continue结束本次循环" class="headerlink" title="continue结束本次循环"></a>continue结束本次循环</h2><p>忽略continue之下的代码，直接进行下一次循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 5&#96;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">    if [ $i &#x3D;&#x3D; 3 ]</span><br><span class="line">    then</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line">echo $i</span><br></pre></td></tr></table></figure><h2 id="exit退出整个脚本"><a href="#exit退出整个脚本" class="headerlink" title="exit退出整个脚本"></a>exit退出整个脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 5&#96;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">    if [ $i &#x3D;&#x3D; 3 ]</span><br><span class="line">    then</span><br><span class="line">        exit</span><br><span class="line">    fi</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line">echo aaaaaaa</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>select用法 <a href="http://www.apelearn.com/bbs/thread-7950-1-1.html" target="_blank" rel="noopener">http://www.apelearn.com/bbs/thread-7950-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;while循环&lt;br&gt;break跳出循环&lt;br&gt;continue结束本次循环&lt;br&gt;exit退出整个脚本&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>066shell脚本02</title>
    <link href="https://lcf33.github.io/2017/11/09/066shell%E8%84%9A%E6%9C%AC02/"/>
    <id>https://lcf33.github.io/2017/11/09/066shell%E8%84%9A%E6%9C%AC02/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.034Z</updated>
    
    <content type="html"><![CDATA[<p>文件目录属性判断<br>if特殊用法<br>case判断<br>for循环</p><a id="more"></a><h2 id="文件目录属性判断"><a href="#文件目录属性判断" class="headerlink" title="文件目录属性判断"></a>文件目录属性判断</h2><p>[ -f file ]判断是否是普通文件，且存在<br>[ -d file ] 判断是否是目录，且存在<br>[ -e file ] 判断文件或目录是否存在<br>[ -r file ] 判断文件是否可读<br>[ -w file ] 判断文件是否可写<br>[ -x file ] 判断文件是否可执行</p><h2 id="if特殊用法"><a href="#if特殊用法" class="headerlink" title="if特殊用法"></a>if特殊用法</h2><p>[ -z “$a” ]  这个表示当变量a的值为空时会怎么样，z表示zero。<br>[ -n “$a” ] 表示当变量a的值不为空，n表示no zero。<br><code>if grep -q &#39;123&#39; 1.txt; then</code>  表示如果1.txt中含有’123’的行时会怎么样<br><code>if [ ! -e file ]; then</code> 表示文件不存在时会怎么样<br><code>if (($a&lt;1)); then</code> 等同于 <code>if [ $a -lt 1 ]; then</code>。需要注意的是[ ] 中不能使用&lt;,&gt;,==,!=,&gt;=,&lt;=这样的符号。</p><h2 id="case判断"><a href="#case判断" class="headerlink" title="case判断"></a>case判断</h2><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case  变量名 in </span><br><span class="line">  value1)</span><br><span class="line">        command</span><br><span class="line">        ;;</span><br><span class="line">  value2)</span><br><span class="line">        command</span><br><span class="line">        ;;</span><br><span class="line">  *)</span><br><span class="line">        commond</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>在case程序中，可以在条件中使用|，表示或的意思，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2|3) </span><br><span class="line">    command</span><br><span class="line">    ;;</span><br></pre></td></tr></table></figure><p>脚本案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -p &quot;Please input a number: &quot; n</span><br><span class="line">if [ -z &quot;$n&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;Please input a number.&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">n1&#x3D;&#96;echo $n|sed &#39;s&#x2F;[0-9]&#x2F;&#x2F;g&#39;&#96;</span><br><span class="line">if [ -n &quot;$n1&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;Please input a number.&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $n -lt 60 ] &amp;&amp; [ $n -ge 0 ]</span><br><span class="line">then</span><br><span class="line">   tag&#x3D;1 #为了用上case，所以这里打上tag标记</span><br><span class="line">elif [ $n -ge 60 ] &amp;&amp; [ $n -lt 80 ]</span><br><span class="line">then</span><br><span class="line">   tag&#x3D;2</span><br><span class="line">elif [ $n -ge 80 ]  &amp;&amp; [ $n -lt 90 ]</span><br><span class="line">then</span><br><span class="line">   tag&#x3D;3</span><br><span class="line">elif [ $n -ge 90 ] &amp;&amp; [ $n -le 100 ]</span><br><span class="line">then</span><br><span class="line">   tag&#x3D;4</span><br><span class="line">else</span><br><span class="line">   tag&#x3D;0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">case $tag in</span><br><span class="line">    1)</span><br><span class="line">      echo &quot;not ok&quot;</span><br><span class="line">        ;;</span><br><span class="line">    2)</span><br><span class="line">        echo &quot;ok&quot;</span><br><span class="line">        ;;</span><br><span class="line">    3)</span><br><span class="line">        echo &quot;ook&quot;</span><br><span class="line">        ;;</span><br><span class="line">    4)</span><br><span class="line">        echo &quot;oook&quot;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;The number range is 0-100.&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>语法：<code>for 变量名 in 条件; do …; done</code><br>案例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sum&#x3D;0</span><br><span class="line">for i in &#96;seq 1 100&#96;</span><br><span class="line">do</span><br><span class="line">    sum&#x3D;$[$sum+$i]</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><p>案例2<br>目录列表循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">cd &#x2F;etc&#x2F;</span><br><span class="line">for a in &#96;ls &#x2F;etc&#x2F;&#96;</span><br><span class="line">do</span><br><span class="line">    if [ -d $a ]</span><br><span class="line">    then</span><br><span class="line">       ls -d $a</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件目录属性判断&lt;br&gt;if特殊用法&lt;br&gt;case判断&lt;br&gt;for循环&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>065shell脚本01</title>
    <link href="https://lcf33.github.io/2017/11/07/065shell%E8%84%9A%E6%9C%AC01/"/>
    <id>https://lcf33.github.io/2017/11/07/065shell%E8%84%9A%E6%9C%AC01/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.033Z</updated>
    
    <content type="html"><![CDATA[<p>shell脚本介绍<br>shell脚本结构和执行<br>date命令用法<br>shell脚本中的变量<br>shell脚本中的逻辑判断</p><a id="more"></a><h2 id="shell脚本介绍"><a href="#shell脚本介绍" class="headerlink" title="shell脚本介绍"></a>shell脚本介绍</h2><p>shell是一种脚本语言，可以使用逻辑判断、循环等语法，可以自定义函数。</p><p>与其他编程语言不同的是shell没有语言库，许多任务都需要从头实现。但是shell可以调用linux系统命令，这大大扩展了shell脚本的功能。shell脚本可以实现自动化运维，能大大增加我们的运维效率。</p><h2 id="shell脚本结构和执行"><a href="#shell脚本结构和执行" class="headerlink" title="shell脚本结构和执行"></a>shell脚本结构和执行</h2><p>开头需要加#!/bin/bash，指定解释器。此外，以#开头的行作为解释说明，在写脚本时多写一些注释对方便以后维护。</p><p>脚本的名字以.sh结尾，用于区分这是一个shell脚本。</p><p>执行方法有两种：</p><ol><li>为脚本文件增加执行权限<code>chmod +x</code> ，然后就可以直接运行：<code>1.sh</code>或者 <code>./1.sh</code>（相当于相对路径，也可以写绝对路径）</li><li>bash 1.sh</li></ol><p>查看脚本执行过程 <code>bash -x 1.sh</code>。查看脚本是否语法错误  <code>bash -n 1.sh</code>，没有输出提示就是语法正确。</p><h2 id="date命令的用法"><a href="#date命令的用法" class="headerlink" title="date命令的用法"></a>date命令的用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">date  +%Y-%m-%d, date +%y-%m-%d #以年月日的格式输出</span><br><span class="line">date  +%H:%M:%S &#x3D; date +%T #输出时间</span><br><span class="line">date +%s -d “2018-09-09 18:50:20” #时间戳，距离1970年1月1日的时间秒</span><br><span class="line">date -d @1504620492 #时间戳，与上面互换</span><br><span class="line">date -d &quot;+1day&quot;  一天后</span><br><span class="line">date -d &quot;-1 day&quot;  一天前</span><br><span class="line">date -d &quot;-1 month&quot; 一月前</span><br><span class="line">date -d &quot;-1 min&quot;  一分钟前</span><br><span class="line">date +%w, date +%W w星期几，W今年的第几周</span><br></pre></td></tr></table></figure><h2 id="shell脚本中的变量"><a href="#shell脚本中的变量" class="headerlink" title="shell脚本中的变量"></a>shell脚本中的变量</h2><ul><li>当脚本中使用某个字符串较频繁并且字符串长度很长时就应该使用变量代替。</li><li>使用条件语句时，常使用变量。<code>if [ $a -gt 1 ]; then ... ; fi</code>。</li><li>引用某个命令的结果时，用变量替代 <code>n=</code>wc -l 1.txt``</li><li>写和用户交互的脚本时，变量也是必不可少的 <code>read -p &quot;Input a number: &quot; n; echo $n</code>。 如果没写这个n，可以直接使用$REPLY。</li></ul><p>内置变量 $0, $1, $2等等。$0表示脚本本身，$1 第一个参数，$2 第二个，$#表示参数个数。数学运算a=1;b=2; c=$(($a+$b))或者$[$a+$b]。</p><h2 id="shell脚本中的逻辑判断"><a href="#shell脚本中的逻辑判断" class="headerlink" title="shell脚本中的逻辑判断"></a>shell脚本中的逻辑判断</h2><ul><li>格式1：if 条件 ; then 语句; fi</li><li>格式2：if 条件; then 语句; else 语句; fi</li><li>格式3：if …; then … ;elif …; then …; else …; fi</li></ul><p>逻辑判断符号： <code>-gt</code> (&gt;); -<code>lt</code> (&lt;); <code>-ge</code> (&gt;=); <code>-le</code> (&lt;=); <code>-eq</code> (==); <code>-ne</code> (!=)。 注意使用时括号内变量、-gt等左右都有空格，类似这样写逻辑判断表达式：if [ $a -gt $b ]; if [ $a -lt 5 ]; if [ $b -eq 10 ]。</p><p>可以使用 &amp;&amp; || 结合多个条件：<br>if [ $a -gt 5 ] &amp;&amp; [ $a -lt 10 ]; then echo “hello” ;fi<br>if [ $b -gt 5 ] || [ $b -lt 3 ]; then echo “hello”;fi</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shell脚本介绍&lt;br&gt;shell脚本结构和执行&lt;br&gt;date命令用法&lt;br&gt;shell脚本中的变量&lt;br&gt;shell脚本中的逻辑判断&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>064linux集群03负载均行02</title>
    <link href="https://lcf33.github.io/2017/11/05/064linux%E9%9B%86%E7%BE%A403%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%8C02/"/>
    <id>https://lcf33.github.io/2017/11/05/064linux%E9%9B%86%E7%BE%A403%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%8C02/</id>
    <published>2017-11-04T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.032Z</updated>
    
    <content type="html"><![CDATA[<p>LVS DR模式搭建<br>keepalived + LVS</p><a id="more"></a><h2 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h2><p>IP tunnel在生产环境中使用不是很多，nat模式有规模瓶颈。DR模式比较浪费公网ip资源，如果节省可以搭建内网lvs，把公网web的80端口映射到内网vip的80端口。</p><p>两台rs上也编写脚本 vim /usr/local/sbin/lvs_rs.sh//内容如下<br>#/bin/bash<br>vip=192.168.133.200<br>#把vip绑定在lo上，是为了实现rs直接把结果返回给客户端<br>ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up<br>route add -host $vip lo:0<br>#以下操作为更改arp内核参数，目的是为了让rs顺利发送mac地址给客户端<br>#参考文档<a href="http://www.cnblogs.com/lgfeng/archive/2012/10/16/2726308.html" target="_blank" rel="noopener">www.cnblogs.com/lgfeng/archive/2012/10/16/2726308.html</a><br>echo “1” &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore<br>echo “2” &gt;/proc/sys/net/ipv4/conf/lo/arp_announce<br>echo “1” &gt;/proc/sys/net/ipv4/conf/all/arp_ignore<br>echo “2” &gt;/proc/sys/net/ipv4/conf/all/arp_announce<br>分别在dir上和两个rs上执行这些脚本<br>测试</p><p>##keepalived+lvs DR<br>完整架构需要两台服务器（角色为dir）分别安装keepalived软件，目的是实现高可用，但keepalived本身也有负载均衡的功能，所以本次实验可以只安装一台keepalived<br>keepalived内置了ipvsadm的功能，所以不需要再安装ipvsadm包，也不用编写和执行那个lvs_dir的脚本<br>三台机器分别为：<br>dir（安装keepalived）133.130<br>rs1 133.132<br>rs2 133.133<br>vip 133.200</p><p>编辑keepalived配置文件 vim /etc/keepalived/keepalived.conf//内容请到<a href="https://coding.net/u/aminglinux/p/aminglinux-book/git/blob/master/D21Z/lvs_keepalived.conf" target="_blank" rel="noopener">https://coding.net/u/aminglinux/p/aminglinux-book/git/blob/master/D21Z/lvs_keepalived.conf</a> 获取<br>需要更改里面的ip信息<br>执行ipvsadm -C  把之前的ipvsadm规则清空掉<br>systemctl restart network 可以把之前的vip清空掉<br>两台rs上，依然要执行/usr/local/sbin/lvs_rs.sh脚本<br>keepalived有一个比较好的功能，可以在一台rs宕机时，不再把请求转发过去<br>测试</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LVS DR模式搭建&lt;br&gt;keepalived + LVS&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>063linux集群02负载均衡01</title>
    <link href="https://lcf33.github.io/2017/11/03/063linux%E9%9B%86%E7%BE%A402%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A101/"/>
    <id>https://lcf33.github.io/2017/11/03/063linux%E9%9B%86%E7%BE%A402%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A101/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.030Z</updated>
    
    <content type="html"><![CDATA[<p>负载均衡集群介绍<br>LVS介绍<br>LVS调度算法<br>LVS NAT模式搭建</p><a id="more"></a><h2 id="负载均衡介绍"><a href="#负载均衡介绍" class="headerlink" title="负载均衡介绍"></a>负载均衡介绍</h2><p>主流开源软件LVS、keepalived、haproxy、nginx等。其中LVS属于4层（网络OSI 7层模型），nginx属于7层，haproxy既可以认为是4层，也可以当做7层使用。keepalived的负载均衡功能其实就是lvs。</p><p>lvs这种4层的负载均衡是可以分发除80外的其他端口通信的，比如MySQL的，而nginx仅仅支持http，https，mail。haproxy也支持MySQL这种。也不是基于4层就一定好，nginx基于7层可以定制个性化的需求。相比较来说，LVS这种4层的更稳定，能承受更多的请求，而nginx这种7层的更加灵活，能实现更多的个性化需求。</p><h2 id="lvs介绍"><a href="#lvs介绍" class="headerlink" title="lvs介绍"></a>lvs介绍</h2><p>LVS是由国人章文嵩开发，流行度不亚于apache的httpd，基于TCP/IP做的路由和转发，稳定性和效率很高。LVS最新版本基于Linux内核2.6，有好多年不更新了。</p><p>LVS有三种常见的模式：NAT、DR、IP Tunnel。LVS架构中有一个核心角色叫做分发器（Load balancer），它用来分发用户的请求，还有诸多处理用户请求的服务器（Real server，简称rs）</p><p>nat模式这种模式借助iptables的nat表来实现。用户的请求到分发器后，通过预设的iptables规则，把请求的数据包转发到后端的rs上去。rs需要设定网关为分发器的内网ip。用户请求的数据包和返回给用户的数据包全部经过分发器，所以分发器成为瓶颈。一般来说rs十来台，再多就是硬件性能限制了。在nat模式中，只需要分发器有公网ip即可，所以比较节省公网ip资源</p><p>IP tunel模式这种模式，需要有一个公共的IP配置在分发器和所有rs上，我们把它叫做vip。客户端请求的目标IP为vip，分发器接收到请求数据包后，会对数据包做一个加工，会把目标IP改为rs的IP，这样数据包就到了rs上。rs接收数据包后，会还原原始数据包，这样目标IP为vip，因为所有rs上配置了这个vip，所以它会认为是它自己。</p><p>DR模式这种模式，也需要有一个公共的IP配置在分发器和所有rs上，也就是vip。和IP Tunnel不同的是，它会把数据包的MAC地址修改为rs的MAC地址。rs接收数据包后，会还原原始数据包，这样目标IP为vip，因为所有rs上配置了这个vip，所以它会认为是它自己。</p><h2 id="lvs调度算法"><a href="#lvs调度算法" class="headerlink" title="lvs调度算法"></a>lvs调度算法</h2><ol><li>轮询 Round-Robin 简称rr</li><li>加权轮询 Weight Round-Robin 简称wrr</li><li>最小连接 Least-Connection 简称lc</li><li>加权最小连接 Weight Least-Connection 简称wlc</li><li>基于局部性的最小连接 Locality-Based Least Connections 简称lblc</li><li>带复制的基于局部性最小连接 Locality-Based Least Connections with Replication  简称lblcr</li><li>目标地址散列调度 Destination Hashing 简称dh</li><li>源地址散列调度 Source Hashing  简称sh</li></ol><h2 id="nat模式搭建"><a href="#nat模式搭建" class="headerlink" title="nat模式搭建"></a>nat模式搭建</h2><p>准备三台机器。一台作为分发器，也叫调度器（简写为dir），内网：192.168.133.130，外网：147.144（vmware仅主机模式）。另外两台做rs，rs1 内网：192.168.133.132，rs2 内网：192.168.133.133，两台rs网关都设置为192.168.133.130。</p><p>三台机器上都关闭防火墙：<code>systemctl stop firewalld; systemc disable firewalld</code>、<code>systemctl start  iptables.services; iptables -F; service iptables save</code>。使用centos6上的iptables是因为更熟悉些。使用iptables调用空规则，同时把selinux关掉。</p><h2 id="nat搭建"><a href="#nat搭建" class="headerlink" title="nat搭建"></a>nat搭建</h2><p>在dir上安装ipvsadm：<code>yum install -y ipvsdam</code>，它是实现lvs的重要工具，rs上不需要安装。lvs与iptables有点像。</p><p>在dir上编写脚本，vim /usr/local/sbin/lvs_nat.sh//内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># director 服务器上开启路由转发功能</span><br><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</span><br><span class="line"># 关闭icmp的重定向</span><br><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;send_redirects</span><br><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;default&#x2F;send_redirects</span><br><span class="line"># 注意区分网卡名字，我的两个网卡分别为ens33和ens37</span><br><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;ens33&#x2F;send_redirects</span><br><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;ens37&#x2F;send_redirects</span><br><span class="line"># director 设置nat防火墙</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -t nat -X</span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.133.0&#x2F;24  -j MASQUERADE</span><br><span class="line"># director设置ipvsadm</span><br><span class="line">IPVSADM&#x3D;&#39;&#x2F;usr&#x2F;sbin&#x2F;ipvsadm&#39;</span><br><span class="line">$IPVSADM -C</span><br><span class="line">$IPVSADM -A -t 192.168.147.144:80 -s wlc -p 3 #-p 3秒内一直分发到同一个rs</span><br><span class="line">$IPVSADM -a -t 192.168.147.144:80 -r 192.168.133.132:80 -m -w 1</span><br><span class="line">$IPVSADM -a -t 192.168.147.144:80 -r 192.168.133.133:80 -m -w 1</span><br></pre></td></tr></table></figure><p>执行上面的脚本，然后两台rs上都安装nginx做测试。设置两台rs的主页，做一个区分，也就是说直接curl两台rs的ip时，得到不同的结果。浏览器里访问192.168.142.147，多访问几次看结果差异。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>lvs 三种模式详解  <a href="http://www.it165.net/admin/html/201401/2248.html" target="_blank" rel="noopener">http://www.it165.net/admin/html/201401/2248.html</a><br>lvs几种算法 <a href="http://www.aminglinux.com/bbs/thread-7407-1-1.html" target="_blank" rel="noopener">http://www.aminglinux.com/bbs/thread-7407-1-1.html</a><br>关于arp_ignore和 arp_announce <a href="http://www.cnblogs.com/lgfeng/archive/2012/10/16/2726308.html" target="_blank" rel="noopener">http://www.cnblogs.com/lgfeng/archive/2012/10/16/2726308.html</a><br>lvs原理相关的   <a href="http://blog.csdn.net/pi9nc/article/details/23380589" target="_blank" rel="noopener">http://blog.csdn.net/pi9nc/article/details/23380589</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;负载均衡集群介绍&lt;br&gt;LVS介绍&lt;br&gt;LVS调度算法&lt;br&gt;LVS NAT模式搭建&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>062linux集群01高可用</title>
    <link href="https://lcf33.github.io/2017/11/01/062linux%E9%9B%86%E7%BE%A401%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://lcf33.github.io/2017/11/01/062linux%E9%9B%86%E7%BE%A401%E9%AB%98%E5%8F%AF%E7%94%A8/</id>
    <published>2017-10-31T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.029Z</updated>
    
    <content type="html"><![CDATA[<p>集群介绍<br>keepalived介绍<br>用keepalived配置高可用集群</p><a id="more"></a><h2 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h2><p>根据功能划分为两大类：高可用和负载均衡。</p><p>高可用集群通常为两台服务器，一台工作，另外一台作为冗余，当提供服务的机器宕机，冗余将接替继续提供服务。实现高可用的开源软件有：heartbeat、keepalived。</p><p>负载均衡集群，需要有一台服务器作为分发器，它负责把用户的请求分发给后端的服务器处理，在这个集群里，除了分发器外，就是给用户提供服务的服务器，这些服务器数量至少为2。实现负载均衡的开源软件有LVS、keepalived、haproxy、nginx，商业的有F5、Netscaler。</p><h2 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h2><p>在这里我们使用keepalived来实现高可用集群，因为heartbeat在centos6上有一些问题，影响实验效果。keepalived通过VRRP（Virtual Router Redundancy Protocl）来实现高可用。在这个协议里会将多台功能相同的路由器组成一个小组，这个小组里会有1个master角色和N（N&gt;=1）个backup角色。master会通过组播的形式向各个backup发送VRRP协议的数据包，当backup收不到master发来的VRRP数据包时，就会认为master宕机了。此时就需要根据各个backup的优先级来决定谁成为新的mater。</p><p>Keepalived要有三个模块，分别是core、check和vrrp。其中core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析，check模块负责健康检查，vrrp模块是来实现VRRP协议的。</p><h2 id="keepalived配置"><a href="#keepalived配置" class="headerlink" title="keepalived配置"></a>keepalived配置</h2><p>准备两台机器，假设ip分别为192.168.56.130和192.168.56.132。我们为nginx服务做高可用，130作为master，132作为backup。</p><p>两台机器都执行<code>yum install -y keepalived</code>。两台机器都安装nginx，可以编译安装也可以yum安装nginx。设定vip为192.168.56.100。</p><p>编辑130上keepalived配置文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     abc@abclinux.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from root@abclinux.com</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;check_ng.sh&quot;</span><br><span class="line">    interval 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass abclinux&gt;com</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.188.100</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>130编辑监控脚本，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#时间变量，用于记录日志</span><br><span class="line">d&#x3D;&#96;date --date today +%Y%m%d_%H:%M:%S&#96;</span><br><span class="line">#计算nginx进程数量</span><br><span class="line">n&#x3D;&#96;ps -C nginx --no-heading|wc -l&#96;</span><br><span class="line">#如果进程为0，则启动nginx，并且再次检测nginx进程数量，</span><br><span class="line">#如果还为0，说明nginx无法启动，此时需要关闭keepalived</span><br><span class="line">if [ $n -eq &quot;0&quot; ]; then</span><br><span class="line">        &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br><span class="line">        n2&#x3D;&#96;ps -C nginx --no-heading|wc -l&#96;</span><br><span class="line">        if [ $n2 -eq &quot;0&quot;  ]; then</span><br><span class="line">                echo &quot;$d nginx down,keepalived will stop&quot; &gt;&gt; &#x2F;var&#x2F;log&#x2F;check_ng.log</span><br><span class="line">                systemctl stop keepalived</span><br><span class="line">        fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>给脚本755权限</p><p>132上编辑配置文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     abc@abclinux.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from root@abclinux.com</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;check_ng.sh&quot;</span><br><span class="line">    interval 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass abclinux&gt;com</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.188.100</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>132上编辑监控脚本，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#时间变量，用于记录日志</span><br><span class="line">d&#x3D;&#96;date --date today +%Y%m%d_%H:%M:%S&#96;</span><br><span class="line">#计算nginx进程数量</span><br><span class="line">n&#x3D;&#96;ps -C nginx --no-heading|wc -l&#96;</span><br><span class="line">#如果进程为0，则启动nginx，并且再次检测nginx进程数量，</span><br><span class="line">#如果还为0，说明nginx无法启动，此时需要关闭keepalived</span><br><span class="line">if [ $n -eq &quot;0&quot; ]; then</span><br><span class="line">        systemctl start nginx</span><br><span class="line">        n2&#x3D;&#96;ps -C nginx --no-heading|wc -l&#96;</span><br><span class="line">        if [ $n2 -eq &quot;0&quot;  ]; then</span><br><span class="line">                echo &quot;$d nginx down,keepalived will stop&quot; &gt;&gt; &#x2F;var&#x2F;log&#x2F;check_ng.log</span><br><span class="line">                systemctl stop keepalived</span><br><span class="line">        fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>给脚本755权限<br>132上也启动服务 systemctl start keepalived</p><p>先确定好两台机器上nginx差异，比如可以通过curl -I 来查看nginx版本<br>测试1：关闭master上的nginx服务<br>测试2：在master上增加iptabls规则<br>iptables -I OUTPUT -p vrrp -j DROP<br>测试3：关闭master上的keepalived服务<br>测试4：启动master上的keepalived服务</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>heartbeat和keepalived比较<a href="http://blog.csdn.net/yunhua_lee/article/details/9788433" target="_blank" rel="noopener">http://blog.csdn.net/yunhua_lee/article/details/9788433</a><br>DRBD工作原理和配置   <a href="http://502245466.blog.51cto.com/7559397/1298945" target="_blank" rel="noopener">http://502245466.blog.51cto.com/7559397/1298945</a><br>mysql+keepalived <a href="http://lizhenliang.blog.51cto.com/7876557/1362313" target="_blank" rel="noopener">http://lizhenliang.blog.51cto.com/7876557/1362313</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集群介绍&lt;br&gt;keepalived介绍&lt;br&gt;用keepalived配置高可用集群&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>061mysql扩展知识02</title>
    <link href="https://lcf33.github.io/2017/10/30/061mysql%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%8602/"/>
    <id>https://lcf33.github.io/2017/10/30/061mysql%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%8602/</id>
    <published>2017-10-29T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.028Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL扩展案例2</p><a id="more"></a><h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><p>mycat实现分库分表<br><a href="https://www.cnblogs.com/joylee/p/7513038.html" target="_blank" rel="noopener">https://www.cnblogs.com/joylee/p/7513038.html</a><br>atlas   出自于360，不维护不更新了  <a href="https://blog.csdn.net/AnPHPer/article/details/80566385" target="_blank" rel="noopener">https://blog.csdn.net/AnPHPer/article/details/80566385</a><br>mysql环形主从<br><a href="http://ask.apelearn.com/question/11437" target="_blank" rel="noopener">http://ask.apelearn.com/question/11437</a><br>mysql架构演变 <a href="http://www.aminglinux.com/bbs/thread-8025-1-1.html" target="_blank" rel="noopener">http://www.aminglinux.com/bbs/thread-8025-1-1.html</a><br>MHA架构<br><a href="http://blog.51cto.com/xiaoshuaigege/2060768" target="_blank" rel="noopener">http://blog.51cto.com/xiaoshuaigege/2060768</a><br>比较复杂的mysql集群架构 <a href="http://ask.apelearn.com/question/17026" target="_blank" rel="noopener">http://ask.apelearn.com/question/17026</a></p><h2 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h2><p>Mycat官网：<a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a> 可以了解下Mycat的背景和应用情况，这样使用起来比较有信心。Mycat下载地址：<a href="http://dl.mycat.io/" target="_blank" rel="noopener">http://dl.mycat.io/</a> 官网有个文档，属于详细的介绍，初次入门，看起来比较花时间。下载后根据不同的系统选择不同的版本。包括linux、windows、mac,作者考虑还是非常周全的，当然，也有源码版的。</p><p>Mycat的安装其实只要解压下载的目录就可以了，非常简单。安装完成后，目录有bin（mycat命令，启动、重启、停止等）、catlet（catlet为Mycat的一个扩展功能）、conf（Mycat 配置信息,重点关注）、lib（Mycat引用的jar包，Mycat是java开发的）、logs（日志文件，包括Mycat启动的日志和运行的日志）。Mycat的架构其实很好理解，Mycat是代理，Mycat后面就是物理数据库。和Web服务器的Nginx类似。对于使用者来说，访问的都是Mycat，不会接触到后端的数据库。Mycat的配置文件都在conf目录里面，这里介绍几个常用的文件：server.xml（Mycat的配置文件，设置账号、参数等）、schema.xml（Mycat对应的物理数据库和数据库表的配置）、rule.xml（Mycat分片（分库分表）规则）。</p><h2 id="mysql架构发展"><a href="#mysql架构发展" class="headerlink" title="mysql架构发展"></a>mysql架构发展</h2><p>假设一个网站（discuz）从最开始访问量很小做到日pv千万，我们来推测一下它的mysql服务器架构演变过程。</p><p>第一阶段<br>网站访问量日pv量级在1w以下。单台机器跑web和db，不需要做架构层调优（比如，不需要增加memcached缓存）。此时，数据往往都是每日冷备份的，但有时候如果考虑数据安全性，会搭建一个mysql主从。</p><p>第二阶段<br>网站访问量日pv达到几万。此时单台机器已经有点负载，需要我们把web和db分开，需要搭建memcached服务作为缓存。也就是说，在这个阶段，我们还可以使用单台机器跑mysql去承担整个网站的数据存储和查询。如果做mysql主从，目的也是为了数据安全性。</p><p>第三阶段<br>网站访问量日pv达到几十万。单台机器虽然也可以支撑，但是需要的机器配置要比之前的机器好很多。如果经费允许，可以购买配置很高的机器来跑mysql服务，但是并不是说，配置翻倍，性能也翻倍，到了一定阶段配置增加已经不能带来性能的增加。所以，此阶段，我们会想到做mysql服务的集群，也就是说我们可以拿多台机器跑mysql。但，mysql的集群和web集群是不一样的，我们需要考虑数据的一致性，所以不能简单套用做web集群的方式（lvs，nginx代理）。可以做的架构是，mysql主从，一主多从。为了保证架构的健壮和数据完整，主只能是一个，从可以是多个。<br>还有一个问题，我们需要想到，就是在前端web层，我们的程序里面指定了mysql机器的ip，那么当mysql机器有多台时，程序里面如何去配置？discuz，其实有一个功能，支持mysql读写分离。即，我们可以拿多台机器跑mysql，其中一台写，其他多台是读，我们只需要把读和写的ip分别配置到程序中，程序自动会去区分机器。当然，如果不使用discuz自带的配置，我们还可以引用一个软件叫做 mysql-proxy, 使用他来实现读写分离。它支持一主多从的模式。</p><p>第四阶段<br>网站访问量日pv到几百万。之前的一主多从模式已经遇到瓶颈，因为当网站访问量变大，读数据库的量也会越来越大，我们需要多加一些从进来，但是从的数量增加到数十台时，由于主需要把bin-log全部分发到所有从上，那么这个过程本身就是一件很繁琐的事情，再加上频繁读取，势必会造成从上同步过来的数据有很大延迟。所以，我们可以做一个优化，把mysql原来的一主多从变为一主一从，然后从作为其他从的主，而前面的主只负责网站业务的写入，而后面的从不负责网站任何业务，只负责给其他从同步bin-log。这样还可以继续多叠加几个从库。</p><p>第五阶段<br>网站访问量日pv到1千万的时候，我们发现，网站的写入量非常大，我们之前架构中只有一个主，这里的主已经成为瓶颈了。所以，需要再近一步做出调整。比如，我们可以把业务分模块，把用户相关的单独分离出来，把权限、积分等也可以分离出来单独跑一个库，然后再做主从，也就是所谓的分库。当然也可以换一个纬度，把访问量或者写入量大的表单独分离出来，跑在一台服务器上，也可以把一个表分成多个小表。这一步操作，涉及到一些程序上的改动，所以需要事先和开发同事做好沟通和设计。总之，这一步要做的就是分库分表。</p><p>再往后发展，继续把大表分小表即可。 而国内阿里淘宝网站的数据量是巨量的，他们的数据库全部都是mysql，他们的mysql架构就是遵循分库分表这个原则的，只不过他们划分规则会有很多纬度，比如可以根据地域划分，可以根据买家、卖家划分，可以根据时间划分等等。</p><h2 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h2><p>MHA（Master High Availability）是一款开源的mysql高可用程序，目前在mysql高可用方面是一个相对成熟的解决方案。MHA 搭建的前提是MySQL集群中已经搭建了MySql Replication环境，有了Master/Slave节点。MHA的主要作用就是监测到Master节点故障时会提升主从复制环境中拥有最新数据的Slave节点成为新的master节点。同时，在切换master期间，MHA会通过从其他的Slave节点来获取额外的信息来避免一致性的问题，整个的切换过程对于应用程序而言是完全透明的。MHA还提供了master节点在线切换功能，即按需切换master/slave节点。</p><p>MHA 自动切换的原理可以总结为下面几点：</p><ol><li>从宕机崩溃的master保存二进制日志事件（binlog events）;</li><li>识别含有最新更新的slave;</li><li>应用差异的中继日志（relay log）到其他的slave;</li><li>应用从master保存的二进制日志事件（binlog events);</li><li>提升一个slave为新的master;</li><li>使其他的slave连接新的master进行复制;</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL扩展案例2&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>060mysql扩展知识01</title>
    <link href="https://lcf33.github.io/2017/10/28/060mysql%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%8601/"/>
    <id>https://lcf33.github.io/2017/10/28/060mysql%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%8601/</id>
    <published>2017-10-27T16:00:00.000Z</published>
    <updated>2020-06-05T09:03:22.027Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL扩展案例1</p><a id="more"></a><h2 id="12-17mysql扩展（一）"><a href="#12-17mysql扩展（一）" class="headerlink" title="12.17mysql扩展（一）"></a>12.17mysql扩展（一）</h2><p>不停库不锁表在线主从配置<br><a href="http://seanlook.com/2015/12/14/mysql-replicas/" target="_blank" rel="noopener">http://seanlook.com/2015/12/14/mysql-replicas/</a><br>主从不同步<br><a href="http://www.rfyy.net/archives/2309.html" target="_blank" rel="noopener">http://www.rfyy.net/archives/2309.html</a><br><a href="http://blog.51cto.com/storysky/259280" target="_blank" rel="noopener">http://blog.51cto.com/storysky/259280</a><br>主主<br>关于 auto_increment  <a href="https://blog.csdn.net/leshami/article/details/39779509" target="_blank" rel="noopener">https://blog.csdn.net/leshami/article/details/39779509</a><br><a href="http://www.cnblogs.com/ygqygq2/p/6045279.html" target="_blank" rel="noopener">http://www.cnblogs.com/ygqygq2/p/6045279.html</a><br>mysql-proxy 实现读写分离<br><a href="http://blog.51cto.com/zzclinux/1980487" target="_blank" rel="noopener">http://blog.51cto.com/zzclinux/1980487</a><br>mysql-proxy类似的产品有：<br>mycat  基于阿里的开源软件cobar，官网 <a href="http://www.mycat.io" target="_blank" rel="noopener">www.mycat.io</a><br><a href="https://my.oschina.net/ruoli/blog/1789370" target="_blank" rel="noopener">https://my.oschina.net/ruoli/blog/1789370</a></p><h2 id="在线主从配置"><a href="#在线主从配置" class="headerlink" title="在线主从配置"></a>在线主从配置</h2><p>mysqldump对于导出10G以下的数据库或几个表，还是适用的，而且更快捷。一旦数据量达到100-500G，无论是对原库的压力还是导出的性能，mysqldump就力不从心了。Percona-Xtrabackup备份工具，是实现MySQL在线热备工作的不二选择，可进行全量、增量、单表备份和还原。（但当数据量更大时，可能需要考虑分库分表，或使用 LVM 快照来加快备份速度了）</p><p>2.2版本 xtrabackup 能对InnoDB和XtraDB存储引擎的数据库非阻塞地备份，innobackupex通过perl封装了一层xtrabackup，对MyISAM的备份通过加表读锁的方式实现。2.3版本 xtrabackup 命令直接支持MyISAM引擎。</p><p>XtraBackup优势 ：</p><ol><li>无需停止数据库进行InnoDB热备</li><li>增量备份MySQL</li><li>流压缩到传输到其它服务器</li><li>能比较容易地创建主从同步</li><li>备份MySQL时不会增大服务器负载</li></ol><h2 id="主从不同步"><a href="#主从不同步" class="headerlink" title="主从不同步"></a>主从不同步</h2><p>主从同步配置好后，运行了一时间，出现了不同步现象，用命令检查，看到从上报下面错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msyq &gt; show slave status \G;</span><br><span class="line">Last_Errno: 1062</span><br><span class="line">Last_Error: Error &#39;Duplicate entry &#39;149&#39; for key &#39;PRIMARY&#39;&#39; on query. Default database: &#39;zabbix&#39;. Query: &#39;insert into escalations (escalationid,actionid,status,triggerid,itemid,eventid,r_eventid) values (149,7,0,16272,null,3334811,null)&#39;</span><br></pre></td></tr></table></figure><p>看这个报错，应该是主MYSQL上建表时，主键有重复的值报错，造成从不能同步。<br>解决的办法是在从库上执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; slave stop;</span><br><span class="line">mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER&#x3D;1;</span><br><span class="line">mysql&gt; slave start;</span><br></pre></td></tr></table></figure><p>上面的方法可以解决问题，还有一种解决问题的办法是通过修改mysql的配置文件，让从库的同步线程忽略这个错误，方法：</p><p>修改mysql配置文件 /etc/ 在 [mysqld]下加一行 slave_skip_errors = 1062 ,保存重启mysql<br>mysql slave可以正常同步了。</p><p>此外，还有一片介绍修改格式的方法：</p><p>tail -f mysql_error.log 出现大量的<br>…….<br>100106 16:54:21 [Warning] Statement may not be safe to log in statement format. Statement: delete from <code>system_message_1</code> where <code>to_uid</code> = 181464 ORDER BY <code>id</code> ASC LIMIT 1<br>………<br>日志里面有大量的这种警告，意思应该是statement 格式不安全，用vim 打开他看了一下，发现好多这类警告，我说为什么错误日志怎么变这么大了呢！！<br>statement format 应该是 binlog的一种格式，进入从库查看一下<br>show global variables like ‘binlog_format’;<br>果然当前的格式为statement</p><p>我需要把格式改为 mixed格式<br>修改从库的 my.cfg<br>在[mysqld]下面加入下面这行<br>binlog_format=mixed</p><p>然后重启mysql服务，发现错误日志里的 警告 都停止了。</p><p> RBR 模式可以解决很多因为主键冲突导致的主从无法同步情况，于是把 slave-skip-errors = 1062 去掉再试试，<br>进入到 里在注释掉了 slave-skip-errors = 1062<br>再次重新启动 mysql服务<br>进入从库<br>show slave status \G;<br>………<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes<br>……..</p><h2 id="auto-increment"><a href="#auto-increment" class="headerlink" title="auto_increment"></a>auto_increment</h2><p>MySQL中对于表上ID自增列可以在创建表的时候来指定列上的auto_increment属性；等同于SQL server中的identity属性；Oracle则是通过sequence方式来实现。在MySQL中，系统变量auto_increment_increment，auto_increment_offset 影响自增列的值及其变化规则。</p><p>auto_increment_increment控制列中的值的增量值，也就是步长。auto_increment_offset确定AUTO_INCREMENT列值的起点，也就是初始值。变量范围：可以在全局以及session级别设置这2个变量。</p><h2 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h2><p>单主存在单点故障，从库切换成主库需要作改动。因此，如果是双主或者多主，就会增加mysql入口，增加高可用。不过多主需要考虑自增长ID问题，这个需要特别设置配置文件，比如双主，可以使用奇偶，总之，主之间设置自增长ID相互不冲突就能完美解决自增长ID冲突问题。</p><p>MySQL双主（主主）架构方案思路是:</p><ol><li>两台mysql都可读写，互为主备，默认只使用一台（masterA）负责数据的写入，另一台（masterB）备用；</li><li>masterA是masterB的主库，masterB又是masterA的主库，它们互为主从；</li><li>两台主库之间做高可用,可以采用keepalived等方案（使用VIP对外提供服务）；</li><li>所有提供服务的从服务器与masterB进行主从同步（双主多从）;</li><li>建议采用高可用策略的时候，masterA或masterB均不因宕机恢复后而抢占VIP（非抢占模式）；</li></ol><p>这样做可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；</p><p>但是也有几个不足的地方:<br>1.masterB可能会一直处于空闲状态（可以用它当从库，负责部分查询）；<br>2.主库后面提供服务的从库要等masterB先同步完了数据后才能去masterB上去同步数据，这样可能会造成一定程度的同步延时；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL扩展案例1&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://lcf33.github.io/tags/tech/"/>
    
      <category term="Linux" scheme="https://lcf33.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
